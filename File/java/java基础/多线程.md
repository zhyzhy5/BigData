
## 一.进程与线程的基本概念及特点
* 什么是进程？什么是线程？
	1)进程：正在执行的应用程序。
		是系统进行资源调用和分配的单元。
		每一个进程都有自己的系统资源和内存空间。
	2)线程：是进程的执行单元（执行路径），依赖于进程存在而存在。

* 什么是多进程？什么是多线程？
	1)多进程：CPU在同一个时间段内执行多个程序任务。
        CPU高效切换保证了多进程
	2)多线程：一个应用程序有多条执行路径。
        无法保证哪一个线程在什么时间执行，线程有随机性。

* 多进程的好处是什么？多线程的好处是什么？
	1)多进程：提高CPU的使用率，主要应用于高并发环境，桌面程序等。
	2)多线程：提高应用程序的使用率。（注意：无法提高应用程序执行速度）

* 什么是并发？什么是并行？
	1)并发：在某一时间点同时运行多个程序（真正的同时，多核CPU来实现并发）
	2)并行：在某一时间段内同时运行多个程序
	
* Java程序运行原理？
	1)Java命令启动JVM程序（启动进程）
	2)由该进程启动主线程
	3)由主线程调用”main()”方法
	4)jvm虚拟机的启动是多线程的，至少两个线程：A.主线程B.垃圾回收线程

## 二.继承Thread类
* 通过继承Thread类来实现多线程
	1)创建Thread类的子类MyThread
	2)在子类中重写run()方法（把需要备多线程执行的代码放在run()方法里）
	3)在测试类中创建MyThread对象（至少创建两个对象）
	4)分别通过MyThread的两个对象引用来调用start()方法来启动多线程。同一个线程对象不能被多次启动。

	
* run()和start()区别？
	1)run()方法的作用：仅封装被线程执行的代码。单独调用是普通方法
	2)start()方法的作用：
	3)重新单独启动一个线程
	4)由jvm来调用该线程的run()方法


* 线程优先级范围[1,10],默认是5

* 线程休眠（在线程类中调用）：public static void sleep(long millis)
	在指定的毫秒数内让当前正在执行的线程休眠

* 加入线程（在main中调用）：public final void join()
	在对象调用start()方法之后，再用该对象调用join()方法。
	且该线程要放在所有线程对象start()方法的前面执行
	相当于把该线程加入到主线程来执行，等待该线程执行完毕，再执行其他线程

* 礼让线程（在线程类中调用）：public static void yield()
	暂停当前正在执行的线程对象，并执行其他线程。
	能让多线程执行更和谐，但不能完全达到"你一次，我一次"的效果，还需要等待唤醒机制才能解决。

* 后台线程（在main中调用）：public final void setDaemon(boolean on)
	将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，
	Java虚拟机退出。该方法必须在启动线程前调用。

* 中断线程
	1)public final void stop()：强迫线程停止执行，不安全
	2)public void interrupt()：把线程状态终止，并抛一个异常，程序还可以往后执行

	
* sleep()和wait()的区别？
	1)sleep()必须指定时间，wait()可以指定时间，也可以不指定时间（通过notify()来唤醒）
	2)sleep()不释放锁，wait()释放锁。
	3)sleep()通过线程对象调用，wait()通过锁对象(Object)来调用

	
## 三.实现Runable接口
* 通过实现Runnable()接口来实现多线程
	1)自定义MyRunnable()类，实现Runnable()接口
	2)在类中重写run()方法
	3)创建类的对象
	4)创建Thread类的对象，并把C步骤的对象作为构造参数进行传递

* 用Runnable实现多线程的好处
	1)解决了单继承带来的局限性（比如有一个类，已经有了一个父类了，就不能再继承Thread类了，只能通过实现Runnable接口来实现多线程）
	2)适合多个相同程序的代码去处理同一个资源的情况，把线程同程序的代码，数据有效分离，较好的体现了面向对象的设计思想。
	实现Runnable接口来实现多线程

```java
	Runnable r = new Myrunnable();
	//t1,t2访问的都是r的成员变量
	Thread t1 = new Thread("线程一",r);
	Thread t2 = new Thread("线程二",r);
	

	实现Thread类来实现多线程
	Thread t1 = new myThread();
	Thread t2 = new myThread();
	//会在myThread类中产生两组不同的成员变量
```
	C．	如果是继承的Thread类，那么锁对象一定要定义成static类型，这样才是大家公用一把锁
	如果是实现的Runnable接口，那么用”this”作为锁对象就可以了


## 四.线程的生命周期
	1)新建：创建线程对象
	2)就绪：有执行资格，没没有执行权
	3)运行：有执行资格，有执行权
		阻塞：由于一些操作让线程处于了该状态，没有执行资格，没有执行权
		      而另一些操作可以把它激活，激活后处于就绪状态
	4)死亡：线程对象编程垃圾，等待被回收
	新建--就绪--运行--死亡
	新建--就绪--运行--就绪--运行--死亡
	新建--就绪--运行--阻塞--就绪--运行--死亡

## 五.线程同步
* 判断一个程序是否有线程安全问题的标准
	1)是否是多线程环境
	2)是否是多线程环境是否有共享数据
	3)是否有多条语句操作共享数据

* 同步的前提及优缺点：
	1)前提：多个线程，并且使用同一把锁
	2)好处：解决多线程安全问题
	3)缺点：线程很多时，每个线程都会去判断同步上的锁，很耗费资源，会降低程序的运行效率。

* 同步在代码块上，同步在方法上的说明
	1)在同步代码块中，多个线程使用的锁对象必须是同一个对象，该对象可以是任意的
	  格式：synchronized(s){}//这里的s是锁对象，可以是任意对象
	2)在同步方法中，锁对象是”this”
	3)在同步静态方法中，锁对象是该类的字节码文件对象，代码是先编译产生class文件，再将class文件作为锁对象

* 同步的两种办法
	1)使用synchronized
	2)使用Lock类中的lock()和unlock();
	


## 面试题
* 用Java实现阻塞队列





