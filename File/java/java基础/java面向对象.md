
## 一.面向对象
* 面向对象特点
	封装、继承、多态

* 需求分析
	1)首先分析有那些类
	2)接着分析每个类应该有什么
	3)最后分析类与类的关系

* 什么是类和对象
	1)类：可以理解为构造对象的一个蓝图或者模版，是抽象的概念
	2)对象：是以类为模型创建的具体实例，是对类的一种具体化。

* 成员变量、构造方法、成员方法
	1)成员变量：就是事物的属性
	2)构造方法：给对象的数据进行初始化，没有void和return，方法名与类名相同。
	            不能被继承，因此不能被重写，但可以被重载。
	3)成员方法：就是事物的行为

* 成员变量和局部变量的区别
	1)在类中的位置不同
	  成员变量：类中方法外
      局部变量：方法内或者方法声明上
	2)在内存中的位置不同
	  成员变量：堆内存
	  局部变量：栈内存，因为局部变量是在方法中
	3)生命周期不同
	  成员变量：随着对象的存在而存在，随着对象的消失而消失
	  局部变量：随着方法的调用而存在，随着方法的调用完毕而消失
	4)初始化值不同
	  成员变量：有默认的初始化值
	  局部变量：没有默认的初始化值，必须先定义，赋值，才能使用。

	
## 二.方法重载与方法重写
* 方法重载(出现在同一个类中)
	定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。
	特点：
	1)方法名相同并且参数列表不同，分两种情况：
	  1.1)参数个数不同
	  1.2)参数类型不同
	2)与返回值类型无关，与方法的修饰符无关
	3)在调用时，虚拟机通过参数列表的不同来区分同名方法


* 方法重写(出现在子父类中)
	方法重写：子类中，出现了和父类中一模一样的方法声明，也被称为方法覆盖，方法复写
	特点：
	1)父类中私有方法不能被重写，
	2)子类重写父类方法时，访问权限不能更低（最好声明和父类一模一样）
	3)子类重新方法与父类有相同的返回值类型

	
## 三.参数传递
* 参数传递
	1)基本类型：基本类型传递的是值，形参的改变不影响实参的值。
	2)引用类型：引用类型传递的时候地址值，两个引用指向的是同一个堆内存，形参的改变直接影响实参。

* 类、抽象类、接口作为形参的问题
	1)如果一个方法需要的参数是一个类名，这里实际需要的是一个具体的对象。
	2)如果一个方法需要的参数是一个抽象类名，这里实际需要的是一个子类对象。
	3)如果一个方法需要的参数是一个接口名，这里实际需要的是一个子类对象。
	
## 四.Student s = new Student();在内存中做了哪些事情?

* 代码分析
```java
class Student(){
  private String name = “林青霞”;
  private int age = 27;
  public Student(){
	 name = “刘意”;
age = 30;
}}
class StudentDemo(){
  public static void main(String[] args){
	 Student s = new Student();
}}
```
	1)在内存方法区加载类文件：Student.class和StudentDemo.class
	2)在栈内存中加载main()方法
	3)在栈内存为s开辟空间（Student s）
	4)在堆内存为学生对象开辟空间（new Student();）
	5)对学生对象的成员变量进行默认初始化（name=null,age=0）
	6)对学生对象的成员变量进行显示初始化（name=林青霞,age=27）（说明：这步等效成通过构造代码块给成员变量赋值，如果这时有其它构造代码块，那么，就按顺序赋值）
	7)通过构造方法对学生对象的成员变量赋值（name=刘意,age=30）
	8)学生对象初始化完毕，把堆内存中的对象地址赋值给s变量
	
## 五.static关键字
* 静态的特点
	1)随着类的加载而加载
	2)优先于对象存在
	3)被类的所有对象共享	
	4)既可以通过对象名调用，也可以通过类名调用，建议通过类名调用。
	5)静态修饰的，我们一般称其为类成员；非静态的叫对象成员

* 静态内存图解
    ![静态内存图解](https://github.com/zhyzhy5/BigData/blob/master/java/java%E5%9F%BA%E7%A1%80/images/静态内存图解.jpg "静态内存图解")

* 静态的内存图解说明：
	1)将personDemo.class和person.class加载到方法区的class内容区域，同时将静态方法（main()方法）和类变量country加载到方法区中的静态区，并为country赋初始化值（country=null）
	2)main()方法进栈内存
	3)在栈内存中创建对象Person p1，在堆内存中创建new Person()，并在堆内存中为成员变量初始化（name=null，age=0）。此时，在创建对象时，在方法区中创建Person类的方法区（包括所有的构造方法和成员方法）
	4)通过带参构造为堆内存中的p1中的成员方法赋值（name=邓丽君，age= 16），为p1的静态方法赋值（country=中国）
	5)把new Person的地址值赋给p1，此时栈内存中的p1指向堆内存中的new Person()
	6)show()方法进栈内存，打印name=邓丽君，age= 16，country=中国
	7)show()方法调用结束，从栈内存中消失。
	8)在栈内存中创建Person p2

* 静态注意事项
	1)在静态方法中是没有this关键字的，因为static修饰的成员变量或成员方法是和.class文件一起加载的.而"this.num"是在创建对象的时候才开始存在的。静态比对象先存在。先存在的不能访问后存在的，而后存在的可以访问先存在的。

	```java
	class  Teacher{
	    public  int  num = 10;
	    public  static  void  show(){
			System.out.println(num);//报错，show()是类方法，num是成员变量，类方法不能调用成员变量
		}
	}
	```

	2)静态方法只能访问静态的成员变量和静态的成员方法
	
## 六.代码块
* 代码块种类
	1)局部代码块:
	位置：在方法中出现，用{}括起来的代码
	作用：限定变量生命周期，及早释放，提高内存利用率
	2)构造代码块:
	位置：在类中方法外出现，用{}括起来的代码
	作用：多个构造方法中相同的代码存放到一起，每次调用构造方法都执行，并且在构造方法前执行，对对象进行初始化
	3)静态代码块: 在类中方法外出现，用{}括起来的代码，并加上static修饰；
	用于给类进行初始化，在第一次Student s = new Student()时执行，并且只执行一次。对类进行初始化

* 代码块执行顺序
	1)先执行main方法所属类（StudentDemo类）中的静态代码块（只执行一次）
	2)再执行main()方法中的内容
	3)在第一次创建对象的时候（Student s = new Student()），执行Student中的静态代码块。（只执行一次）
	4)再执行构造代码块（只要调用构造方法就执行，调用几次就执行几次）
	5)构造方法最后执行
	
## 七.继承
* 什么是继承？什么时候用继承？
	存在"is a"的关系。比如：Person类和Student类，存在"Student is a Person"，所以可以使用Student extends Person

	
* 在继承中，子类如何访问父类的构造方法
	1)子类的构造方法默认会去访问父类的无参构造方法，是为了子类访问父类数据的初始化
	也就是说，在创建子类对象（无论使用无参还是带参构造）的时候，就会访问父类的无参构造，如果父类的无参构造会有一条输出语句，那么，在编译的时候，就会把这条语句打印在控制台上。
	为什么要访问父类的无参呢？
	是为了先对父类中的数据进行初始化，为了以后使用。
	子类每一个构造方法的第一行都是super();
	2)如果父类中只有带参构造方法，没有无参构造方法，那么编译会出现什么现象呢？
	会报错。
	3)如果父类中没有无参构造，只有带参构造，怎么办呢？有以下三个方法
	3.1)在父类中再增加一个无参构造方法
	3.2)子类通过super(…);直接访问父类的带参构造;(其中“…”的意思是，父类带参构造的数据类型是什么，该出就填写什么类型的数据)。原理是：
	3.3)只要访问了父类中的构造方法，就可以给父类中的成员变量进行初始化。
	3.4)子类可以通过this调用子类其它构造方法（前提是访问了父类的带参构造）间接访问父类带参构造，原理同方法b

* 继承的注意事项：
	1)super();或this();必须在子类构造的第一条语句上
	如果不放在第一条语句上，那个第一条语句默认已经有super();相当于给父类多次初始化
	this()同理。
	2)在子类中，如果声明了无参构造，那么必须访问父类的带参构造。如果没有声明无参构造，必须要其它带参构造访问父类的带参构造
	3)子类不能继承父类的私有成员
	4)子类不能继承父类的构造方法，但是可以通过super去访问

* this和super
	this:代表当前类的对象引用
	super:代表父类存储空间的标识。(可以理解为父类的引用，通过这个东西可以访问父类的成员)
	this和super各自的用法
	1)访问成员变量
	this.成员变量;		super.成员变量;
	2)访问构造方法(子父类的构造方法问题讲)
	this(…);		super(…);
	3)访问成员方法(子父类的成员方法问题讲)
	this.成员方法();	super.成员方法();

* 类的加载顺序及初始化顺序
	1)加载Fu类（加载静态）
	2)加载Zi类（加载静态）
	3)加载Fu的构造
	4)加载Zi的构造
	执行顺序：父类静态―>子类静态―>父类成员变量初始化―>父类构造方法初始化―>子类成员变量初始化―>子类构造方法初始化
	原理是子父类的初始化，是分层初始化，先初始化父类，再初始化子类
	其中，如果父类中的静态包含，静态代码块，静态成员变量等，那么谁在前面，先执行谁。

## 八.多态
* 多态的前提
	1)有继承或实现关系
	2)有方法重写
	3)有父类或父接口引用指向子类对象（Person p = new Student();）

* 多态成员变量访问特点
	1)成员变量：编译看左边（父类定义了该成员变量，编译就通过），运行看左边（父类中该成员变量的值是多少？运行结果就是多少）
	2)成员方法：编译看左边（父类定义了该成员方法，编译就通过），运行看右边（因为方法被子类重写，所以运行结果是子类方法的结果）
	  由于成员方法存在方法重写，所以"运行看右边"。
	3)静态方法：编译看左边，运行看左边

* 多态的三种方式:
	1)具体类多态（几乎用不到）
	2)抽象类多态
	3)接口多态（最常用）


* 多态的优缺点
    优点：提高代码维护性；提高了代码扩展性（不用修改工具类，直接添加子类）
	弊端：不能使用子类特有功能(父类中没有，但子类中有的功能)
	不能使用子类特有功能(父类中没有，但子类中有的功能)
	可以使用向下转型来解决Fu f = new zi();Zi z = (Zi) f;(向下转型，转型后可以调用子类特有方法)

```
class abstract Animal{ //动物类，封装动物的功能
	public abstract void eat();  
	public abstract void sleep();
}

class Cat extends Animal{//子类猫，继承动物，重写动物的方法
	eat(){
		System.out.println("猫吃鱼")
	}   
	sleep(){
		System.out.println("猫站着睡")
	}
}

class Dog extends Animal{
	eat(){
		System.out.println("狗吃肉")
	}     //子类狗，继承动物，重写动物的方法
	sleep(){
		System.out.println("狗趴着睡")
	}
}

class animalTool{//工具类调用动物的方法
	public static void user(Animal a){
	c.eat();
	c.sleep();
	}
}    

classDemo{//测试类，创建父类引用指向子类对象
	public static void main(String[] args){ 
		Animal a = new Cat ;Animal a2 = new Dog;
	}
}

```
	
## 九.抽象类
* 抽象类的特点
	1)类中如果有抽象方法，该类必须定义为抽象类。
	2)抽象类中不一定有抽象方法（意义：不让创建抽象类对象，只能通过子类来创建对象。）
	3)由具体的子类实例化，抽象类多态。

* 抽象类的子类特点
	要么是抽象类；要么重写抽象类中所有抽象方法
	
* 抽象类中的成员特点：
	1)成员变量：可以是变量，也可以是常量。
	2)构造方法：仅用于子类访问父类数据的初始化
	3)成员方法：抽象类中可以有抽象方法也可以有非抽象方法
	3.1)抽象类的抽象方法：用于限定子类必须完成某些动作
	3.2)抽象类的非抽象方法：用于提高代码的复用性

* 抽象方法不能与以下关键字共存
	private void show(){}，private修饰的方法不能被继承，子类无法重写抽象类方法；所以要用public
	final，final修饰的方法不能被重写
	static，通过类名调用一个没有方法体的方法，所以没有意义

## 十.接口
* 接口的子类
	可以是抽象类。可以是具体类，必须重写接口中的抽象方法（推荐）

* 接口中的元素
    成员变量：只能是常量。默认修饰符：public static final
	接口中没有构造方法
	接口中的方法可以是抽象方法。也可以是default修饰的方法
	
* 接口和抽象类的区别
	1)成员区别
		抽象类：(对事物进行抽象，举例：猫是类，狗是类，动物是抽象类)(抽象类是“是不是”的关系，举例：猫是动物，狗是动物)
			成员变量：可以变量，也可以常量
			构造方法：有
			成员方法：可以抽象，也可以非抽象
			抽象类中，可以有静态方法和静态代码块
		接口：(对行为进行抽象，举例：飞机是类，鸟是类，飞翔是接口)(接口是“有没有”的关系，鸟有飞翔的功能，飞机有飞翔的功能)
			成员变量：只可以常量
			成员方法：只可以抽象
			接口中不能有静态方法和静态代码块
	2)关系区别
		类与类
			继承，单继承
		类与接口
			实现，单实现，多实现
		接口与接口
			继承，单继承，多继承
	3)设计理念区别
		抽象类 被继承体现的是：”is a”的关系。抽象类中定义的是该继承体系的共性功能。
		接口 被实现体现的是：”like a”的关系。接口中定义的是该继承体系的扩展功能。

* 常见的类及其组成的修饰
	
	类：
		(默认,public)(final)(abstract)
		常用的：public
	成员变量：
		(private,默认,protected,public)(static,final)
		常用的：private
	构造方法：
		(private,默认,protected,public)
		常用的：public
	成员方法：所有修饰符都可以用
		常用的：public
		
## 十一.内部类
* 内部类的特点
	
	成员内部类：
	1)Outer.Inner oi = new Outer().newInner();
	局部内部类（在方法中的类）：
	1)可以直接访问外部类的成员
	2)可以创建内部类对象，通过对象调用内部类方法，来使用局部内部类功能
	
* 内部类的修饰符问题
	
	一般来说，内部类是不让外界来访问的，用private修饰;
	内部类可以用static修饰，是因为内部类可以看做是外部类的成员。

* 内部类注意事项
	
	1)被静态修饰的成员内部类只能访问外部类的静态成员（因为static修饰的成员是随着类的加载而加载）
	2)非静态的成员内部类，成员只能是非静态的。
	3)内部类被static修饰后，内部类里的方法有静态和非静态之分。

```java
	class Outer{
		class static Inner{
			public static void show2(){
				System.out.println(100)
			}
			public void show1(){
				System.out.println(100)
			}
		}
	}
	//访问成员静态内部类的非静态方法：
	Outer.Inner oi = new Outer.Inner(); 
	oi.show1();
	oi.show2();

	//访问成员静态内部类的静态方法：
	Outer.Inner.show2(); 
```

* 通过外部类名限定this对象

```java
	class Outer{
		public int num = 10;
		class Inner{
			public void show(){
				System.out.println(Outer.this.num);//访问外部类中的成员变量num
			}
		}
	} 

```

* 局部内部类访问局部变量的注意事项：

	必须被final修饰，原因：因为局部变量会随着方法的调用完毕而消失，这个时候，局部对象并没有立马从堆内存中消失，还要使用那个变量。为了让数据还能继续被使用，就用fianl修饰，这样，在堆内存里面存储的其实是一个常量值。

```java
class Outer {
	private int num = 10;
	public void method() {
		//int num2 = 20;
		//final int num2 = 20;
		class Inner {
			public void show() {
				System.out.println(num);
				//从内部类中访问本地变量num2; 需要被声明为最终类型
				System.out.println(num2);//20
			}
		}
		
		//System.out.println(num2);
		Inner i = new Inner();
		i.show();
	}
}

class InnerClassDemo5 {
	public static void main(String[] args) {
		Outer o = new Outer();
		o.method();
	}
}
```

* 匿名内部类
	1)是局部内部类的简化形式
	2)前提：存在一个类（具体类或抽象类都可以）或者接口
	3)匿名内部类格式：new 类名或者接口名() {重写方法;}
	4)匿名内部类的本质：是一个继承了类或者实现了接口的子类匿名对象

* 匿名内部类面试题

```java
interface Inter { 
	void show(); 
}

class Outer {
	public static Inter method() {
		return new Inter() {
			public void show() {
				System.out.println("HelloWorld");
			}
		};	
	}
}
			
class OuterDemo {
	public static void main(String[] args) {
		/*1:Outer.method()可以看出method()应该是Outer中的一个静态方法。
		2:Outer.method().show()可以看出method()方法的返回值是一个对象。
		又由于接口Inter中有一个show()方法,所以我认为method()方法的返回值类型是一个接口*/
		Outer.method().show();
	}
}
```


	